-- Schema improvements based on analysis
-- This migration implements several improvements to the database schema

-- 1. Create ENUMs for platform and like types
DO $$ BEGIN
    CREATE TYPE public.platform_type AS ENUM ('ios', 'android', 'web');
    CREATE TYPE public.like_type AS ENUM ('like', 'superlike', 'pass');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- 2. Add recommended indexes for performance
CREATE INDEX IF NOT EXISTS idx_matches_users ON public.matches(user_a, user_b);
CREATE INDEX IF NOT EXISTS idx_messages_match_created ON public.messages(match_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_event_occurrences_dates ON public.event_occurrences(starts_at, ends_at);

-- 3. Create venues and cities tables for normalization
CREATE TABLE IF NOT EXISTS public.venues (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    city_id bigint NOT NULL,
    created_at timestamptz DEFAULT now(),
    UNIQUE(name, city_id)
);

CREATE TABLE IF NOT EXISTS public.cities (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    country text NOT NULL,
    created_at timestamptz DEFAULT now()
);

-- Add foreign key to venues
ALTER TABLE public.venues
ADD CONSTRAINT venues_city_id_fkey
FOREIGN KEY (city_id) REFERENCES public.cities(id);

-- 4. Create match_reads table for better read tracking
CREATE TABLE IF NOT EXISTS public.match_reads (
    match_id bigint NOT NULL,
    user_id uuid NOT NULL,
    last_read_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT match_reads_pkey PRIMARY KEY (match_id, user_id),
    CONSTRAINT match_reads_match_id_fkey FOREIGN KEY (match_id) REFERENCES public.matches(id),
    CONSTRAINT match_reads_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id)
);

-- 5. Create function to calculate age
CREATE OR REPLACE FUNCTION public.calculate_age(birthdate date)
RETURNS integer AS $$
BEGIN
    RETURN date_part('year', age(birthdate::date));
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- 6. Modify existing tables

-- Update profiles to use calculated age
ALTER TABLE public.profiles
DROP COLUMN IF EXISTS age,
ADD COLUMN IF NOT EXISTS calculated_age 
    integer GENERATED ALWAYS AS (public.calculate_age(birthdate)) STORED;

-- Add check constraint for minimum age
ALTER TABLE public.profiles
DROP CONSTRAINT IF EXISTS profiles_age_check,
ADD CONSTRAINT profiles_birthdate_check 
    CHECK (public.calculate_age(birthdate) >= 18);

-- Convert platform type in push_tokens
ALTER TABLE public.push_tokens DROP CONSTRAINT IF EXISTS push_tokens_platform_check;
ALTER TABLE public.push_tokens ALTER COLUMN platform DROP NOT NULL;
UPDATE public.push_tokens SET platform = NULL WHERE platform NOT IN ('ios', 'android', 'web');
ALTER TABLE public.push_tokens
ALTER COLUMN platform TYPE public.platform_type 
    USING CASE 
        WHEN platform = 'ios' THEN 'ios'::public.platform_type
        WHEN platform = 'android' THEN 'android'::public.platform_type
        WHEN platform = 'web' THEN 'web'::public.platform_type
    END;

-- Convert type in likes (using a new column to avoid trigger issues)
ALTER TABLE public.likes ADD COLUMN new_type public.like_type;
UPDATE public.likes SET new_type = 
    CASE 
        WHEN type = 'like' THEN 'like'::public.like_type
        WHEN type = 'superlike' THEN 'superlike'::public.like_type
        WHEN type = 'pass' THEN 'pass'::public.like_type
        ELSE 'like'::public.like_type
    END;
ALTER TABLE public.likes DROP CONSTRAINT IF EXISTS likes_type_check;
ALTER TABLE public.likes DROP COLUMN type CASCADE;
ALTER TABLE public.likes RENAME COLUMN new_type TO type;
ALTER TABLE public.likes ALTER COLUMN type SET NOT NULL;
ALTER TABLE public.likes ALTER COLUMN type SET DEFAULT 'like'::public.like_type;

-- Recreate the like trigger
CREATE OR REPLACE FUNCTION public.handle_like_create()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.type = 'like'::public.like_type AND EXISTS (
    SELECT 1 FROM public.likes
    WHERE liker = NEW.liked
    AND liked = NEW.liker
    AND type = 'like'::public.like_type
  ) THEN
    INSERT INTO public.matches (user_a, user_b, created_by_like_id, superlike)
    VALUES (
      LEAST(NEW.liker, NEW.liked),
      GREATEST(NEW.liker, NEW.liked),
      NEW.id,
      NEW.type = 'superlike'::public.like_type
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_like_create
  AFTER INSERT ON public.likes
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_like_create();

-- Add venue_id and city_id to events and event_occurrences
ALTER TABLE public.events
ADD COLUMN IF NOT EXISTS venue_id bigint,
ADD COLUMN IF NOT EXISTS city_id bigint,
ADD CONSTRAINT events_venue_id_fkey 
    FOREIGN KEY (venue_id) REFERENCES public.venues(id),
ADD CONSTRAINT events_city_id_fkey 
    FOREIGN KEY (city_id) REFERENCES public.cities(id);

ALTER TABLE public.event_occurrences
ADD COLUMN IF NOT EXISTS venue_id bigint,
ADD COLUMN IF NOT EXISTS city_id bigint,
ADD CONSTRAINT event_occurrences_venue_id_fkey 
    FOREIGN KEY (venue_id) REFERENCES public.venues(id),
ADD CONSTRAINT event_occurrences_city_id_fkey 
    FOREIGN KEY (city_id) REFERENCES public.cities(id);

-- 7. Create views for convenience
CREATE OR REPLACE VIEW public.active_matches AS
SELECT m.*, 
    GREATEST(m.last_message_at, mr_a.last_read_at, mr_b.last_read_at) as last_activity_at
FROM public.matches m
LEFT JOIN public.match_reads mr_a ON m.id = mr_a.match_id AND m.user_a = mr_a.user_id
LEFT JOIN public.match_reads mr_b ON m.id = mr_b.match_id AND m.user_b = mr_b.user_id
WHERE m.last_message_at > NOW() - INTERVAL '3 months';

-- 8. Create function for archiving old matches
CREATE OR REPLACE FUNCTION public.archive_inactive_matches(older_than interval)
RETURNS integer AS $$
DECLARE
    archived_count integer;
BEGIN
    WITH inactive_matches AS (
        SELECT id FROM public.matches
        WHERE last_message_at < NOW() - older_than
    )
    SELECT COUNT(*) INTO archived_count
    FROM inactive_matches;

    -- Here you would implement the actual archiving logic
    -- For now, we just return the count of matches that would be archived
    
    RETURN archived_count;
END;
$$ LANGUAGE plpgsql;

-- 9. Add RLS policies for new tables
ALTER TABLE public.venues ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.match_reads ENABLE ROW LEVEL SECURITY;

-- Cities and venues are readable by all authenticated users
CREATE POLICY cities_select ON public.cities
    FOR SELECT TO authenticated
    USING (true);

CREATE POLICY venues_select ON public.venues
    FOR SELECT TO authenticated
    USING (true);

-- Match reads are only accessible by the involved users
CREATE POLICY match_reads_select ON public.match_reads
    FOR SELECT TO authenticated
    USING (
        user_id = auth.uid() OR 
        EXISTS (
            SELECT 1 FROM public.matches m 
            WHERE m.id = match_id 
            AND (m.user_a = auth.uid() OR m.user_b = auth.uid())
        )
    );

CREATE POLICY match_reads_insert ON public.match_reads
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());

CREATE POLICY match_reads_update ON public.match_reads
    FOR UPDATE TO authenticated
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Allow admins to manage cities and venues
CREATE POLICY cities_admin ON public.cities
    FOR ALL TO authenticated
    USING ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()))
    WITH CHECK ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()));

CREATE POLICY venues_admin ON public.venues
    FOR ALL TO authenticated
    USING ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()))
    WITH CHECK ((SELECT is_admin FROM public.profiles WHERE id = auth.uid()));

-- 10. Create migration helper function for venues/cities
CREATE OR REPLACE FUNCTION public.migrate_venue_data()
RETURNS void AS $$
DECLARE
    v_city_id bigint;
    v_venue_id bigint;
    v_city text;
    v_venue text;
    v_record record;
BEGIN
    -- Migrate unique cities from events
    FOR v_city IN 
        SELECT DISTINCT city 
        FROM (
            SELECT city FROM public.events WHERE city IS NOT NULL
            UNION
            SELECT city FROM public.event_occurrences WHERE city IS NOT NULL
        ) unique_cities
    LOOP
        INSERT INTO public.cities (name, country)
        VALUES (v_city, 'Unknown')
        ON CONFLICT (name) DO NOTHING;
    END LOOP;

    -- Migrate venues and update references
    FOR v_record IN
        SELECT DISTINCT venue, city
        FROM (
            SELECT venue, city FROM public.events 
            WHERE venue IS NOT NULL AND city IS NOT NULL
            UNION
            SELECT venue, city FROM public.event_occurrences 
            WHERE venue IS NOT NULL AND city IS NOT NULL
        ) unique_venues
    LOOP
        -- Get city id
        SELECT id INTO v_city_id 
        FROM public.cities 
        WHERE name = v_record.city;

        -- Insert venue if it doesn't exist
        INSERT INTO public.venues (name, city_id)
        VALUES (v_record.venue, v_city_id)
        ON CONFLICT (name, city_id) DO NOTHING
        RETURNING id INTO v_venue_id;

        -- If venue was already inserted, get its id
        IF v_venue_id IS NULL THEN
            SELECT id INTO v_venue_id 
            FROM public.venues 
            WHERE name = v_record.venue AND city_id = v_city_id;
        END IF;

        -- Update events
        UPDATE public.events
        SET venue_id = v_venue_id,
            city_id = v_city_id
        WHERE venue = v_record.venue 
        AND city = v_record.city;

        -- Update event_occurrences
        UPDATE public.event_occurrences
        SET venue_id = v_venue_id,
            city_id = v_city_id
        WHERE venue = v_record.venue 
        AND city = v_record.city;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- 11. Migrate existing data
SELECT public.migrate_venue_data();

-- 12. Create indexes for new tables
CREATE INDEX IF NOT EXISTS idx_venues_city ON public.venues(city_id);
CREATE INDEX IF NOT EXISTS idx_match_reads_user ON public.match_reads(user_id);
CREATE INDEX IF NOT EXISTS idx_events_venue_city ON public.events(venue_id, city_id);
CREATE INDEX IF NOT EXISTS idx_event_occurrences_venue_city ON public.event_occurrences(venue_id, city_id);